package wpgma;

import java.util.*;
import java.util.Map.Entry;

public class WPGMATable {
	private HashMap<String,HashMap<String,Double>> dataTable;
	//stores the distances generated by the algorithm
	private HashMap<String,HashMap<String,Double>> distanceTable = null;
	
	public WPGMATable(HashMap<String,HashMap<String,Double>> input) {
		dataTable = input;
	}
	//implement constructor that can manually add in data from the parameters
	
	//create getter functions
	public String getSpeciesA(String key){
		if(dataTable.containsKey(key))return key;
		else return "Species cannot be found";
	}
	
	public Double getDistance(String species1, String species2){
		System.out.println("Returning distance between species A and B: \n");
		if(dataTable.get(species1).containsKey(species2)) {
			System.out.println("done\n");
			return dataTable.get(species1).get(species2);
		}
		else{
			System.out.println("Value not found");
			return null;
		}
	}
	
	//create exist functions
	public boolean exists(String species){
		return dataTable.containsKey(species);
	}
	public boolean distExists(String a, String b){
		return dataTable.get(a).get(b)!=null;
	}
	public boolean isEmpty(){
		return dataTable.isEmpty();
	}
	//check base condition of a chart, must have a distance value for each pairing
	//returns any pairing that does not contain a distance value
	@SuppressWarnings("null")
	public HashMap<String,String> checkInput(){
		HashMap<String,String> missing = null;
		for(Entry<String, HashMap<String, Double>> speciesA:dataTable.entrySet()){
			String firstSpecies = speciesA.getKey();
			for(Entry<String, HashMap<String, Double>> speciesB:dataTable.entrySet()){
				String secondSpecies = speciesB.getKey();
				if(dataTable.get(firstSpecies).get(secondSpecies)==null){
					missing.put(firstSpecies,secondSpecies);
				}
			}
		}
		return missing;
	}
	
	//returns true if not incomplete pairings are found and the chart is complete
	//should be used only for initial charts before they are transformed into trees
	public boolean check(){
		return checkInput()==null;
	}
	
	//create algorithm to calculate distance on a tree
	public Double calculateAvg(Double dist){
		return dist/2;
	}
	//create a function where it can find the distance between a two species and a new one
	public Double calculateAvg(Double dA, Double dB){
		return (dA+dB)/2;
	}
	
	//find the min distance in the table and returns a completed hashmap of pairwise distances
	public HashMap<String,HashMap<String,Double>> getMinDist(HashMap<String,HashMap<String,Double>> table){
		HashMap<String,HashMap<String,Double>> input = table;
		if(table.isEmpty()) return input;
		if(table.size()==1){
			System.out.println(table.size());
			System.out.println("You've reached the end of the chart");
			
		}
		//HashMap<String,HashMap<String,Double>> input = table;
		String SA = null,SB = null;
		Double minDistance = 0.0;
		
		for(HashMap<String,Double> s: input.values()){
			s.remove(SA);//removes the nested key-value from the overall hashmap
			s.remove(SB);
		}
		
		for(String speciesA: input.keySet()){
			HashMap<String,Double> secondSpecies = input.get(speciesA); //get the value of specific key
			
			for(Double speciesB: secondSpecies.values()){//the values in the nested hashmap
				if(speciesB>minDistance){//get min distance in the whole table
					minDistance = speciesB; //store the min distance 
					SA = speciesA; //store the name of species A
					for(Entry<String, Double> e : secondSpecies.entrySet()){
						if(e.getValue()==minDistance)SB = e.getKey(); //store the name of species B
					}
					//distanceTable.put(speciesA, new HashMap<String,Double>().put(speciesB,avgDist));
				}
			}
		}
		System.out.println(SA); //test output
		System.out.println(SB);
	
		//update chart
		String key1 = SA+" "+SB;
		
		HashMap<String,Double> value1 = new HashMap<String,Double>();
		
			for(String s: input.keySet()){ //update the input chart
				if(SA.equals(s)||SB.equals(s)){}
				else{
					Double a = input.get(s).get(SA);
					Double b = input.get(s).get(SB);
					Double d = calculateAvg(a,b);
					value1.put(s, d);
				}
				//key1.replace('*', ',');
				input.put(key1, value1);
			}
			
		
		//take out used values
		input.remove(SA); //removes the 1st species used from the table
		input.remove(SB); //removes the 2nd species used from the table
		
		
		input.put(key1,value1);
		return getMinDist(input);
	}
	
	/**
	//generate distance values for the tree
	public void generate(HashMap<String,HashMap<String,Double>> table){
		//supposed to run the 
		HashMap<String,HashMap<String,Double>> input = table;
		//calc the min value
		Double minDist = getMinDist(input);
	}
	**/	
}
